// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fake

import (
	"io"
	"sync"
)

// MockRenderer is a mock implementation of importer.Renderer.
//
// 	func TestSomethingThatUsesRenderer(t *testing.T) {
//
// 		// make and configure a mocked importer.Renderer
// 		mockedRenderer := &MockRenderer{
// 			RenderContentFunc: func(raw io.ReadCloser, context any) (io.ReadCloser, error) {
// 				panic("mock out the RenderContent method")
// 			},
// 			RenderStringFunc: func(raw string, context any) (string, error) {
// 				panic("mock out the RenderString method")
// 			},
// 		}
//
// 		// use mockedRenderer in code that requires importer.Renderer
// 		// and then make assertions.
//
// 	}
type MockRenderer struct {
	// RenderContentFunc mocks the RenderContent method.
	RenderContentFunc func(raw io.ReadCloser, context any) (io.ReadCloser, error)

	// RenderStringFunc mocks the RenderString method.
	RenderStringFunc func(raw string, context any) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// RenderContent holds details about calls to the RenderContent method.
		RenderContent []struct {
			// Raw is the raw argument value.
			Raw io.ReadCloser
			// Context is the context argument value.
			Context any
		}
		// RenderString holds details about calls to the RenderString method.
		RenderString []struct {
			// Raw is the raw argument value.
			Raw string
			// Context is the context argument value.
			Context any
		}
	}
	lockRenderContent sync.RWMutex
	lockRenderString  sync.RWMutex
}

// RenderContent calls RenderContentFunc.
func (mock *MockRenderer) RenderContent(raw io.ReadCloser, context any) (io.ReadCloser, error) {
	if mock.RenderContentFunc == nil {
		panic("MockRenderer.RenderContentFunc: method is nil but Renderer.RenderContent was just called")
	}
	callInfo := struct {
		Raw     io.ReadCloser
		Context any
	}{
		Raw:     raw,
		Context: context,
	}
	mock.lockRenderContent.Lock()
	mock.calls.RenderContent = append(mock.calls.RenderContent, callInfo)
	mock.lockRenderContent.Unlock()
	return mock.RenderContentFunc(raw, context)
}

// RenderContentCalls gets all the calls that were made to RenderContent.
// Check the length with:
//     len(mockedRenderer.RenderContentCalls())
func (mock *MockRenderer) RenderContentCalls() []struct {
	Raw     io.ReadCloser
	Context any
} {
	var calls []struct {
		Raw     io.ReadCloser
		Context any
	}
	mock.lockRenderContent.RLock()
	calls = mock.calls.RenderContent
	mock.lockRenderContent.RUnlock()
	return calls
}

// RenderString calls RenderStringFunc.
func (mock *MockRenderer) RenderString(raw string, context any) (string, error) {
	if mock.RenderStringFunc == nil {
		panic("MockRenderer.RenderStringFunc: method is nil but Renderer.RenderString was just called")
	}
	callInfo := struct {
		Raw     string
		Context any
	}{
		Raw:     raw,
		Context: context,
	}
	mock.lockRenderString.Lock()
	mock.calls.RenderString = append(mock.calls.RenderString, callInfo)
	mock.lockRenderString.Unlock()
	return mock.RenderStringFunc(raw, context)
}

// RenderStringCalls gets all the calls that were made to RenderString.
// Check the length with:
//     len(mockedRenderer.RenderStringCalls())
func (mock *MockRenderer) RenderStringCalls() []struct {
	Raw     string
	Context any
} {
	var calls []struct {
		Raw     string
		Context any
	}
	mock.lockRenderString.RLock()
	calls = mock.calls.RenderString
	mock.lockRenderString.RUnlock()
	return calls
}
