// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package common_mock

import (
	"github.com/keptn/keptn/resource-service/common"
	"sync"
)

// IGitMock is a mock implementation of common.IGit.
//
// 	func TestSomethingThatUsesIGit(t *testing.T) {
//
// 		// make and configure a mocked common.IGit
// 		mockedIGit := &IGitMock{
// 			CheckoutBranchFunc: func(gitContext common.GitContext, branch string) error {
// 				panic("mock out the CheckoutBranch method")
// 			},
// 			CloneRepoFunc: func(gitContext common.GitContext) (bool, error) {
// 				panic("mock out the CloneRepo method")
// 			},
// 			CreateBranchFunc: func(gitContext common.GitContext, branch string, sourceBranch string) error {
// 				panic("mock out the CreateBranch method")
// 			},
// 			GetDefaultBranchFunc: func(gitContext common.GitContext)  {
// 				panic("mock out the GetDefaultBranch method")
// 			},
// 			ProjectExistsFunc: func(gitContext common.GitContext) bool {
// 				panic("mock out the ProjectExists method")
// 			},
// 			PullFunc: func(gitContext common.GitContext) error {
// 				panic("mock out the Pull method")
// 			},
// 			PushFunc: func(gitContext common.GitContext) error {
// 				panic("mock out the Push method")
// 			},
// 			StageAndCommitAllFunc: func(gitContext common.GitContext, message string) error {
// 				panic("mock out the StageAndCommitAll method")
// 			},
// 		}
//
// 		// use mockedIGit in code that requires common.IGit
// 		// and then make assertions.
//
// 	}
type IGitMock struct {
	// CheckoutBranchFunc mocks the CheckoutBranch method.
	CheckoutBranchFunc func(gitContext common.GitContext, branch string) error

	// CloneRepoFunc mocks the CloneRepo method.
	CloneRepoFunc func(gitContext common.GitContext) (bool, error)

	// CreateBranchFunc mocks the CreateBranch method.
	CreateBranchFunc func(gitContext common.GitContext, branch string, sourceBranch string) error

	// GetDefaultBranchFunc mocks the GetDefaultBranch method.
	GetDefaultBranchFunc func(gitContext common.GitContext)

	// ProjectExistsFunc mocks the ProjectExists method.
	ProjectExistsFunc func(gitContext common.GitContext) bool

	// PullFunc mocks the Pull method.
	PullFunc func(gitContext common.GitContext) error

	// PushFunc mocks the Push method.
	PushFunc func(gitContext common.GitContext) error

	// StageAndCommitAllFunc mocks the StageAndCommitAll method.
	StageAndCommitAllFunc func(gitContext common.GitContext, message string) error

	// calls tracks calls to the methods.
	calls struct {
		// CheckoutBranch holds details about calls to the CheckoutBranch method.
		CheckoutBranch []struct {
			// GitContext is the gitContext argument value.
			GitContext common.GitContext
			// Branch is the branch argument value.
			Branch string
		}
		// CloneRepo holds details about calls to the CloneRepo method.
		CloneRepo []struct {
			// GitContext is the gitContext argument value.
			GitContext common.GitContext
		}
		// CreateBranch holds details about calls to the CreateBranch method.
		CreateBranch []struct {
			// GitContext is the gitContext argument value.
			GitContext common.GitContext
			// Branch is the branch argument value.
			Branch string
			// SourceBranch is the sourceBranch argument value.
			SourceBranch string
		}
		// GetDefaultBranch holds details about calls to the GetDefaultBranch method.
		GetDefaultBranch []struct {
			// GitContext is the gitContext argument value.
			GitContext common.GitContext
		}
		// ProjectExists holds details about calls to the ProjectExists method.
		ProjectExists []struct {
			// GitContext is the gitContext argument value.
			GitContext common.GitContext
		}
		// Pull holds details about calls to the Pull method.
		Pull []struct {
			// GitContext is the gitContext argument value.
			GitContext common.GitContext
		}
		// Push holds details about calls to the Push method.
		Push []struct {
			// GitContext is the gitContext argument value.
			GitContext common.GitContext
		}
		// StageAndCommitAll holds details about calls to the StageAndCommitAll method.
		StageAndCommitAll []struct {
			// GitContext is the gitContext argument value.
			GitContext common.GitContext
			// Message is the message argument value.
			Message string
		}
	}
	lockCheckoutBranch    sync.RWMutex
	lockCloneRepo         sync.RWMutex
	lockCreateBranch      sync.RWMutex
	lockGetDefaultBranch  sync.RWMutex
	lockProjectExists     sync.RWMutex
	lockPull              sync.RWMutex
	lockPush              sync.RWMutex
	lockStageAndCommitAll sync.RWMutex
}

// CheckoutBranch calls CheckoutBranchFunc.
func (mock *IGitMock) CheckoutBranch(gitContext common.GitContext, branch string) error {
	if mock.CheckoutBranchFunc == nil {
		panic("IGitMock.CheckoutBranchFunc: method is nil but IGit.CheckoutBranch was just called")
	}
	callInfo := struct {
		GitContext common.GitContext
		Branch     string
	}{
		GitContext: gitContext,
		Branch:     branch,
	}
	mock.lockCheckoutBranch.Lock()
	mock.calls.CheckoutBranch = append(mock.calls.CheckoutBranch, callInfo)
	mock.lockCheckoutBranch.Unlock()
	return mock.CheckoutBranchFunc(gitContext, branch)
}

// CheckoutBranchCalls gets all the calls that were made to CheckoutBranch.
// Check the length with:
//     len(mockedIGit.CheckoutBranchCalls())
func (mock *IGitMock) CheckoutBranchCalls() []struct {
	GitContext common.GitContext
	Branch     string
} {
	var calls []struct {
		GitContext common.GitContext
		Branch     string
	}
	mock.lockCheckoutBranch.RLock()
	calls = mock.calls.CheckoutBranch
	mock.lockCheckoutBranch.RUnlock()
	return calls
}

// CloneRepo calls CloneRepoFunc.
func (mock *IGitMock) CloneRepo(gitContext common.GitContext) (bool, error) {
	if mock.CloneRepoFunc == nil {
		panic("IGitMock.CloneRepoFunc: method is nil but IGit.CloneRepo was just called")
	}
	callInfo := struct {
		GitContext common.GitContext
	}{
		GitContext: gitContext,
	}
	mock.lockCloneRepo.Lock()
	mock.calls.CloneRepo = append(mock.calls.CloneRepo, callInfo)
	mock.lockCloneRepo.Unlock()
	return mock.CloneRepoFunc(gitContext)
}

// CloneRepoCalls gets all the calls that were made to CloneRepo.
// Check the length with:
//     len(mockedIGit.CloneRepoCalls())
func (mock *IGitMock) CloneRepoCalls() []struct {
	GitContext common.GitContext
} {
	var calls []struct {
		GitContext common.GitContext
	}
	mock.lockCloneRepo.RLock()
	calls = mock.calls.CloneRepo
	mock.lockCloneRepo.RUnlock()
	return calls
}

// CreateBranch calls CreateBranchFunc.
func (mock *IGitMock) CreateBranch(gitContext common.GitContext, branch string, sourceBranch string) error {
	if mock.CreateBranchFunc == nil {
		panic("IGitMock.CreateBranchFunc: method is nil but IGit.CreateBranch was just called")
	}
	callInfo := struct {
		GitContext   common.GitContext
		Branch       string
		SourceBranch string
	}{
		GitContext:   gitContext,
		Branch:       branch,
		SourceBranch: sourceBranch,
	}
	mock.lockCreateBranch.Lock()
	mock.calls.CreateBranch = append(mock.calls.CreateBranch, callInfo)
	mock.lockCreateBranch.Unlock()
	return mock.CreateBranchFunc(gitContext, branch, sourceBranch)
}

// CreateBranchCalls gets all the calls that were made to CreateBranch.
// Check the length with:
//     len(mockedIGit.CreateBranchCalls())
func (mock *IGitMock) CreateBranchCalls() []struct {
	GitContext   common.GitContext
	Branch       string
	SourceBranch string
} {
	var calls []struct {
		GitContext   common.GitContext
		Branch       string
		SourceBranch string
	}
	mock.lockCreateBranch.RLock()
	calls = mock.calls.CreateBranch
	mock.lockCreateBranch.RUnlock()
	return calls
}

// GetDefaultBranch calls GetDefaultBranchFunc.
func (mock *IGitMock) GetDefaultBranch(gitContext common.GitContext) {
	if mock.GetDefaultBranchFunc == nil {
		panic("IGitMock.GetDefaultBranchFunc: method is nil but IGit.GetDefaultBranch was just called")
	}
	callInfo := struct {
		GitContext common.GitContext
	}{
		GitContext: gitContext,
	}
	mock.lockGetDefaultBranch.Lock()
	mock.calls.GetDefaultBranch = append(mock.calls.GetDefaultBranch, callInfo)
	mock.lockGetDefaultBranch.Unlock()
	mock.GetDefaultBranchFunc(gitContext)
}

// GetDefaultBranchCalls gets all the calls that were made to GetDefaultBranch.
// Check the length with:
//     len(mockedIGit.GetDefaultBranchCalls())
func (mock *IGitMock) GetDefaultBranchCalls() []struct {
	GitContext common.GitContext
} {
	var calls []struct {
		GitContext common.GitContext
	}
	mock.lockGetDefaultBranch.RLock()
	calls = mock.calls.GetDefaultBranch
	mock.lockGetDefaultBranch.RUnlock()
	return calls
}

// ProjectExists calls ProjectExistsFunc.
func (mock *IGitMock) ProjectExists(gitContext common.GitContext) bool {
	if mock.ProjectExistsFunc == nil {
		panic("IGitMock.ProjectExistsFunc: method is nil but IGit.ProjectExists was just called")
	}
	callInfo := struct {
		GitContext common.GitContext
	}{
		GitContext: gitContext,
	}
	mock.lockProjectExists.Lock()
	mock.calls.ProjectExists = append(mock.calls.ProjectExists, callInfo)
	mock.lockProjectExists.Unlock()
	return mock.ProjectExistsFunc(gitContext)
}

// ProjectExistsCalls gets all the calls that were made to ProjectExists.
// Check the length with:
//     len(mockedIGit.ProjectExistsCalls())
func (mock *IGitMock) ProjectExistsCalls() []struct {
	GitContext common.GitContext
} {
	var calls []struct {
		GitContext common.GitContext
	}
	mock.lockProjectExists.RLock()
	calls = mock.calls.ProjectExists
	mock.lockProjectExists.RUnlock()
	return calls
}

// Pull calls PullFunc.
func (mock *IGitMock) Pull(gitContext common.GitContext) error {
	if mock.PullFunc == nil {
		panic("IGitMock.PullFunc: method is nil but IGit.Pull was just called")
	}
	callInfo := struct {
		GitContext common.GitContext
	}{
		GitContext: gitContext,
	}
	mock.lockPull.Lock()
	mock.calls.Pull = append(mock.calls.Pull, callInfo)
	mock.lockPull.Unlock()
	return mock.PullFunc(gitContext)
}

// PullCalls gets all the calls that were made to Pull.
// Check the length with:
//     len(mockedIGit.PullCalls())
func (mock *IGitMock) PullCalls() []struct {
	GitContext common.GitContext
} {
	var calls []struct {
		GitContext common.GitContext
	}
	mock.lockPull.RLock()
	calls = mock.calls.Pull
	mock.lockPull.RUnlock()
	return calls
}

// Push calls PushFunc.
func (mock *IGitMock) Push(gitContext common.GitContext) error {
	if mock.PushFunc == nil {
		panic("IGitMock.PushFunc: method is nil but IGit.Push was just called")
	}
	callInfo := struct {
		GitContext common.GitContext
	}{
		GitContext: gitContext,
	}
	mock.lockPush.Lock()
	mock.calls.Push = append(mock.calls.Push, callInfo)
	mock.lockPush.Unlock()
	return mock.PushFunc(gitContext)
}

// PushCalls gets all the calls that were made to Push.
// Check the length with:
//     len(mockedIGit.PushCalls())
func (mock *IGitMock) PushCalls() []struct {
	GitContext common.GitContext
} {
	var calls []struct {
		GitContext common.GitContext
	}
	mock.lockPush.RLock()
	calls = mock.calls.Push
	mock.lockPush.RUnlock()
	return calls
}

// StageAndCommitAll calls StageAndCommitAllFunc.
func (mock *IGitMock) StageAndCommitAll(gitContext common.GitContext, message string) error {
	if mock.StageAndCommitAllFunc == nil {
		panic("IGitMock.StageAndCommitAllFunc: method is nil but IGit.StageAndCommitAll was just called")
	}
	callInfo := struct {
		GitContext common.GitContext
		Message    string
	}{
		GitContext: gitContext,
		Message:    message,
	}
	mock.lockStageAndCommitAll.Lock()
	mock.calls.StageAndCommitAll = append(mock.calls.StageAndCommitAll, callInfo)
	mock.lockStageAndCommitAll.Unlock()
	return mock.StageAndCommitAllFunc(gitContext, message)
}

// StageAndCommitAllCalls gets all the calls that were made to StageAndCommitAll.
// Check the length with:
//     len(mockedIGit.StageAndCommitAllCalls())
func (mock *IGitMock) StageAndCommitAllCalls() []struct {
	GitContext common.GitContext
	Message    string
} {
	var calls []struct {
		GitContext common.GitContext
		Message    string
	}
	mock.lockStageAndCommitAll.RLock()
	calls = mock.calls.StageAndCommitAll
	mock.lockStageAndCommitAll.RUnlock()
	return calls
}
