// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fake

import (
	"helm.sh/helm/v3/pkg/chart"
	"helm.sh/helm/v3/pkg/release"
	"sync"
)

// IHelperMock is a mock implementation of helm.IHelper.
//
// 	func TestSomethingThatUsesIHelper(t *testing.T) {
//
// 		// make and configure a mocked helm.IHelper
// 		mockedIHelper := &IHelperMock{
// 			DownloadChartFunc: func(chartRepoURL string) (*chart.Chart, error) {
// 				panic("mock out the DownloadChart method")
// 			},
// 			GetHistoryFunc: func(releaseName string, namespace string) ([]*release.Release, error) {
// 				panic("mock out the GetHistory method")
// 			},
// 			GetValuesFunc: func(releaseName string, namespace string) (map[string]interface{}, error) {
// 				panic("mock out the GetValues method")
// 			},
// 			UninstallReleaseFunc: func(releaseName string, namespace string) error {
// 				panic("mock out the UninstallRelease method")
// 			},
// 			UpgradeChartFunc: func(ch *chart.Chart, releaseName string, namespace string, vals map[string]interface{}) error {
// 				panic("mock out the UpgradeChart method")
// 			},
// 		}
//
// 		// use mockedIHelper in code that requires helm.IHelper
// 		// and then make assertions.
//
// 	}
type IHelperMock struct {
	// DownloadChartFunc mocks the DownloadChart method.
	DownloadChartFunc func(chartRepoURL string) (*chart.Chart, error)

	// GetHistoryFunc mocks the GetHistory method.
	GetHistoryFunc func(releaseName string, namespace string) ([]*release.Release, error)

	// GetValuesFunc mocks the GetValues method.
	GetValuesFunc func(releaseName string, namespace string) (map[string]interface{}, error)

	// UninstallReleaseFunc mocks the UninstallRelease method.
	UninstallReleaseFunc func(releaseName string, namespace string) error

	// UpgradeChartFunc mocks the UpgradeChart method.
	UpgradeChartFunc func(ch *chart.Chart, releaseName string, namespace string, vals map[string]interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// DownloadChart holds details about calls to the DownloadChart method.
		DownloadChart []struct {
			// ChartRepoURL is the chartRepoURL argument value.
			ChartRepoURL string
		}
		// GetHistory holds details about calls to the GetHistory method.
		GetHistory []struct {
			// ReleaseName is the releaseName argument value.
			ReleaseName string
			// Namespace is the namespace argument value.
			Namespace string
		}
		// GetValues holds details about calls to the GetValues method.
		GetValues []struct {
			// ReleaseName is the releaseName argument value.
			ReleaseName string
			// Namespace is the namespace argument value.
			Namespace string
		}
		// UninstallRelease holds details about calls to the UninstallRelease method.
		UninstallRelease []struct {
			// ReleaseName is the releaseName argument value.
			ReleaseName string
			// Namespace is the namespace argument value.
			Namespace string
		}
		// UpgradeChart holds details about calls to the UpgradeChart method.
		UpgradeChart []struct {
			// Ch is the ch argument value.
			Ch *chart.Chart
			// ReleaseName is the releaseName argument value.
			ReleaseName string
			// Namespace is the namespace argument value.
			Namespace string
			// Vals is the vals argument value.
			Vals map[string]interface{}
		}
	}
	lockDownloadChart    sync.RWMutex
	lockGetHistory       sync.RWMutex
	lockGetValues        sync.RWMutex
	lockUninstallRelease sync.RWMutex
	lockUpgradeChart     sync.RWMutex
}

// DownloadChart calls DownloadChartFunc.
func (mock *IHelperMock) DownloadChart(chartRepoURL string) (*chart.Chart, error) {
	if mock.DownloadChartFunc == nil {
		panic("IHelperMock.DownloadChartFunc: method is nil but IHelper.DownloadChart was just called")
	}
	callInfo := struct {
		ChartRepoURL string
	}{
		ChartRepoURL: chartRepoURL,
	}
	mock.lockDownloadChart.Lock()
	mock.calls.DownloadChart = append(mock.calls.DownloadChart, callInfo)
	mock.lockDownloadChart.Unlock()
	return mock.DownloadChartFunc(chartRepoURL)
}

// DownloadChartCalls gets all the calls that were made to DownloadChart.
// Check the length with:
//     len(mockedIHelper.DownloadChartCalls())
func (mock *IHelperMock) DownloadChartCalls() []struct {
	ChartRepoURL string
} {
	var calls []struct {
		ChartRepoURL string
	}
	mock.lockDownloadChart.RLock()
	calls = mock.calls.DownloadChart
	mock.lockDownloadChart.RUnlock()
	return calls
}

// GetHistory calls GetHistoryFunc.
func (mock *IHelperMock) GetHistory(releaseName string, namespace string) ([]*release.Release, error) {
	if mock.GetHistoryFunc == nil {
		panic("IHelperMock.GetHistoryFunc: method is nil but IHelper.GetHistory was just called")
	}
	callInfo := struct {
		ReleaseName string
		Namespace   string
	}{
		ReleaseName: releaseName,
		Namespace:   namespace,
	}
	mock.lockGetHistory.Lock()
	mock.calls.GetHistory = append(mock.calls.GetHistory, callInfo)
	mock.lockGetHistory.Unlock()
	return mock.GetHistoryFunc(releaseName, namespace)
}

// GetHistoryCalls gets all the calls that were made to GetHistory.
// Check the length with:
//     len(mockedIHelper.GetHistoryCalls())
func (mock *IHelperMock) GetHistoryCalls() []struct {
	ReleaseName string
	Namespace   string
} {
	var calls []struct {
		ReleaseName string
		Namespace   string
	}
	mock.lockGetHistory.RLock()
	calls = mock.calls.GetHistory
	mock.lockGetHistory.RUnlock()
	return calls
}

// GetValues calls GetValuesFunc.
func (mock *IHelperMock) GetValues(releaseName string, namespace string) (map[string]interface{}, error) {
	if mock.GetValuesFunc == nil {
		panic("IHelperMock.GetValuesFunc: method is nil but IHelper.GetValues was just called")
	}
	callInfo := struct {
		ReleaseName string
		Namespace   string
	}{
		ReleaseName: releaseName,
		Namespace:   namespace,
	}
	mock.lockGetValues.Lock()
	mock.calls.GetValues = append(mock.calls.GetValues, callInfo)
	mock.lockGetValues.Unlock()
	return mock.GetValuesFunc(releaseName, namespace)
}

// GetValuesCalls gets all the calls that were made to GetValues.
// Check the length with:
//     len(mockedIHelper.GetValuesCalls())
func (mock *IHelperMock) GetValuesCalls() []struct {
	ReleaseName string
	Namespace   string
} {
	var calls []struct {
		ReleaseName string
		Namespace   string
	}
	mock.lockGetValues.RLock()
	calls = mock.calls.GetValues
	mock.lockGetValues.RUnlock()
	return calls
}

// UninstallRelease calls UninstallReleaseFunc.
func (mock *IHelperMock) UninstallRelease(releaseName string, namespace string) error {
	if mock.UninstallReleaseFunc == nil {
		panic("IHelperMock.UninstallReleaseFunc: method is nil but IHelper.UninstallRelease was just called")
	}
	callInfo := struct {
		ReleaseName string
		Namespace   string
	}{
		ReleaseName: releaseName,
		Namespace:   namespace,
	}
	mock.lockUninstallRelease.Lock()
	mock.calls.UninstallRelease = append(mock.calls.UninstallRelease, callInfo)
	mock.lockUninstallRelease.Unlock()
	return mock.UninstallReleaseFunc(releaseName, namespace)
}

// UninstallReleaseCalls gets all the calls that were made to UninstallRelease.
// Check the length with:
//     len(mockedIHelper.UninstallReleaseCalls())
func (mock *IHelperMock) UninstallReleaseCalls() []struct {
	ReleaseName string
	Namespace   string
} {
	var calls []struct {
		ReleaseName string
		Namespace   string
	}
	mock.lockUninstallRelease.RLock()
	calls = mock.calls.UninstallRelease
	mock.lockUninstallRelease.RUnlock()
	return calls
}

// UpgradeChart calls UpgradeChartFunc.
func (mock *IHelperMock) UpgradeChart(ch *chart.Chart, releaseName string, namespace string, vals map[string]interface{}) error {
	if mock.UpgradeChartFunc == nil {
		panic("IHelperMock.UpgradeChartFunc: method is nil but IHelper.UpgradeChart was just called")
	}
	callInfo := struct {
		Ch          *chart.Chart
		ReleaseName string
		Namespace   string
		Vals        map[string]interface{}
	}{
		Ch:          ch,
		ReleaseName: releaseName,
		Namespace:   namespace,
		Vals:        vals,
	}
	mock.lockUpgradeChart.Lock()
	mock.calls.UpgradeChart = append(mock.calls.UpgradeChart, callInfo)
	mock.lockUpgradeChart.Unlock()
	return mock.UpgradeChartFunc(ch, releaseName, namespace, vals)
}

// UpgradeChartCalls gets all the calls that were made to UpgradeChart.
// Check the length with:
//     len(mockedIHelper.UpgradeChartCalls())
func (mock *IHelperMock) UpgradeChartCalls() []struct {
	Ch          *chart.Chart
	ReleaseName string
	Namespace   string
	Vals        map[string]interface{}
} {
	var calls []struct {
		Ch          *chart.Chart
		ReleaseName string
		Namespace   string
		Vals        map[string]interface{}
	}
	mock.lockUpgradeChart.RLock()
	calls = mock.calls.UpgradeChart
	mock.lockUpgradeChart.RUnlock()
	return calls
}
