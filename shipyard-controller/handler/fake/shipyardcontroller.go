// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fake

import (
	"github.com/keptn/keptn/shipyard-controller/common"
	"github.com/keptn/keptn/shipyard-controller/models"
	"sync"
)

// IShipyardControllerMock is a mock implementation of handler.IShipyardController.
//
// 	func TestSomethingThatUsesIShipyardController(t *testing.T) {
//
// 		// make and configure a mocked handler.IShipyardController
// 		mockedIShipyardController := &IShipyardControllerMock{
// 			ControlSequenceFunc: func(controlSequence common.SequenceControl) error {
// 				panic("mock out the ControlSequence method")
// 			},
// 			GetAllTriggeredEventsFunc: func(filter common.EventFilter) ([]models.Event, error) {
// 				panic("mock out the GetAllTriggeredEvents method")
// 			},
// 			GetTriggeredEventsOfProjectFunc: func(project string, filter common.EventFilter) ([]models.Event, error) {
// 				panic("mock out the GetTriggeredEventsOfProject method")
// 			},
// 			HandleIncomingEventFunc: func(event models.Event, waitForCompletion bool) error {
// 				panic("mock out the HandleIncomingEvent method")
// 			},
// 			StartTaskSequenceFunc: func(event models.Event) error {
// 				panic("mock out the StartTaskSequence method")
// 			},
// 		}
//
// 		// use mockedIShipyardController in code that requires handler.IShipyardController
// 		// and then make assertions.
//
// 	}
type IShipyardControllerMock struct {
	// ControlSequenceFunc mocks the ControlSequence method.
	ControlSequenceFunc func(controlSequence models.SequenceControl) error

	// GetAllTriggeredEventsFunc mocks the GetAllTriggeredEvents method.
	GetAllTriggeredEventsFunc func(filter common.EventFilter) ([]models.Event, error)

	// GetTriggeredEventsOfProjectFunc mocks the GetTriggeredEventsOfProject method.
	GetTriggeredEventsOfProjectFunc func(project string, filter common.EventFilter) ([]models.Event, error)

	// HandleIncomingEventFunc mocks the HandleIncomingEvent method.
	HandleIncomingEventFunc func(event models.Event, waitForCompletion bool) error

	// StartTaskSequenceFunc mocks the StartTaskSequence method.
	StartTaskSequenceFunc func(event models.Event) error

	// calls tracks calls to the methods.
	calls struct {
		// ControlSequence holds details about calls to the ControlSequence method.
		ControlSequence []struct {
			// ControlSequence is the controlSequence argument value.
			ControlSequence models.SequenceControl
		}
		// GetAllTriggeredEvents holds details about calls to the GetAllTriggeredEvents method.
		GetAllTriggeredEvents []struct {
			// Filter is the filter argument value.
			Filter common.EventFilter
		}
		// GetTriggeredEventsOfProject holds details about calls to the GetTriggeredEventsOfProject method.
		GetTriggeredEventsOfProject []struct {
			// Project is the project argument value.
			Project string
			// Filter is the filter argument value.
			Filter common.EventFilter
		}
		// HandleIncomingEvent holds details about calls to the HandleIncomingEvent method.
		HandleIncomingEvent []struct {
			// Event is the event argument value.
			Event models.Event
			// WaitForCompletion is the waitForCompletion argument value.
			WaitForCompletion bool
		}
		// StartTaskSequence holds details about calls to the StartTaskSequence method.
		StartTaskSequence []struct {
			// Event is the event argument value.
			Event models.Event
		}
	}
	lockControlSequence             sync.RWMutex
	lockGetAllTriggeredEvents       sync.RWMutex
	lockGetTriggeredEventsOfProject sync.RWMutex
	lockHandleIncomingEvent         sync.RWMutex
	lockStartTaskSequence           sync.RWMutex
}

// ControlSequence calls ControlSequenceFunc.
func (mock *IShipyardControllerMock) ControlSequence(controlSequence models.SequenceControl) error {
	if mock.ControlSequenceFunc == nil {
		panic("IShipyardControllerMock.ControlSequenceFunc: method is nil but IShipyardController.ControlSequence was just called")
	}
	callInfo := struct {
		ControlSequence models.SequenceControl
	}{
		ControlSequence: controlSequence,
	}
	mock.lockControlSequence.Lock()
	mock.calls.ControlSequence = append(mock.calls.ControlSequence, callInfo)
	mock.lockControlSequence.Unlock()
	return mock.ControlSequenceFunc(controlSequence)
}

// ControlSequenceCalls gets all the calls that were made to ControlSequence.
// Check the length with:
//     len(mockedIShipyardController.ControlSequenceCalls())
func (mock *IShipyardControllerMock) ControlSequenceCalls() []struct {
	ControlSequence models.SequenceControl
} {
	var calls []struct {
		ControlSequence models.SequenceControl
	}
	mock.lockControlSequence.RLock()
	calls = mock.calls.ControlSequence
	mock.lockControlSequence.RUnlock()
	return calls
}

// GetAllTriggeredEvents calls GetAllTriggeredEventsFunc.
func (mock *IShipyardControllerMock) GetAllTriggeredEvents(filter common.EventFilter) ([]models.Event, error) {
	if mock.GetAllTriggeredEventsFunc == nil {
		panic("IShipyardControllerMock.GetAllTriggeredEventsFunc: method is nil but IShipyardController.GetAllTriggeredEvents was just called")
	}
	callInfo := struct {
		Filter common.EventFilter
	}{
		Filter: filter,
	}
	mock.lockGetAllTriggeredEvents.Lock()
	mock.calls.GetAllTriggeredEvents = append(mock.calls.GetAllTriggeredEvents, callInfo)
	mock.lockGetAllTriggeredEvents.Unlock()
	return mock.GetAllTriggeredEventsFunc(filter)
}

// GetAllTriggeredEventsCalls gets all the calls that were made to GetAllTriggeredEvents.
// Check the length with:
//     len(mockedIShipyardController.GetAllTriggeredEventsCalls())
func (mock *IShipyardControllerMock) GetAllTriggeredEventsCalls() []struct {
	Filter common.EventFilter
} {
	var calls []struct {
		Filter common.EventFilter
	}
	mock.lockGetAllTriggeredEvents.RLock()
	calls = mock.calls.GetAllTriggeredEvents
	mock.lockGetAllTriggeredEvents.RUnlock()
	return calls
}

// GetTriggeredEventsOfProject calls GetTriggeredEventsOfProjectFunc.
func (mock *IShipyardControllerMock) GetTriggeredEventsOfProject(project string, filter common.EventFilter) ([]models.Event, error) {
	if mock.GetTriggeredEventsOfProjectFunc == nil {
		panic("IShipyardControllerMock.GetTriggeredEventsOfProjectFunc: method is nil but IShipyardController.GetTriggeredEventsOfProject was just called")
	}
	callInfo := struct {
		Project string
		Filter  common.EventFilter
	}{
		Project: project,
		Filter:  filter,
	}
	mock.lockGetTriggeredEventsOfProject.Lock()
	mock.calls.GetTriggeredEventsOfProject = append(mock.calls.GetTriggeredEventsOfProject, callInfo)
	mock.lockGetTriggeredEventsOfProject.Unlock()
	return mock.GetTriggeredEventsOfProjectFunc(project, filter)
}

// GetTriggeredEventsOfProjectCalls gets all the calls that were made to GetTriggeredEventsOfProject.
// Check the length with:
//     len(mockedIShipyardController.GetTriggeredEventsOfProjectCalls())
func (mock *IShipyardControllerMock) GetTriggeredEventsOfProjectCalls() []struct {
	Project string
	Filter  common.EventFilter
} {
	var calls []struct {
		Project string
		Filter  common.EventFilter
	}
	mock.lockGetTriggeredEventsOfProject.RLock()
	calls = mock.calls.GetTriggeredEventsOfProject
	mock.lockGetTriggeredEventsOfProject.RUnlock()
	return calls
}

// HandleIncomingEvent calls HandleIncomingEventFunc.
func (mock *IShipyardControllerMock) HandleIncomingEvent(event models.Event, waitForCompletion bool) error {
	if mock.HandleIncomingEventFunc == nil {
		panic("IShipyardControllerMock.HandleIncomingEventFunc: method is nil but IShipyardController.HandleIncomingEvent was just called")
	}
	callInfo := struct {
		Event             models.Event
		WaitForCompletion bool
	}{
		Event:             event,
		WaitForCompletion: waitForCompletion,
	}
	mock.lockHandleIncomingEvent.Lock()
	mock.calls.HandleIncomingEvent = append(mock.calls.HandleIncomingEvent, callInfo)
	mock.lockHandleIncomingEvent.Unlock()
	return mock.HandleIncomingEventFunc(event, waitForCompletion)
}

// HandleIncomingEventCalls gets all the calls that were made to HandleIncomingEvent.
// Check the length with:
//     len(mockedIShipyardController.HandleIncomingEventCalls())
func (mock *IShipyardControllerMock) HandleIncomingEventCalls() []struct {
	Event             models.Event
	WaitForCompletion bool
} {
	var calls []struct {
		Event             models.Event
		WaitForCompletion bool
	}
	mock.lockHandleIncomingEvent.RLock()
	calls = mock.calls.HandleIncomingEvent
	mock.lockHandleIncomingEvent.RUnlock()
	return calls
}

// StartTaskSequence calls StartTaskSequenceFunc.
func (mock *IShipyardControllerMock) StartTaskSequence(event models.Event) error {
	if mock.StartTaskSequenceFunc == nil {
		panic("IShipyardControllerMock.StartTaskSequenceFunc: method is nil but IShipyardController.StartTaskSequence was just called")
	}
	callInfo := struct {
		Event models.Event
	}{
		Event: event,
	}
	mock.lockStartTaskSequence.Lock()
	mock.calls.StartTaskSequence = append(mock.calls.StartTaskSequence, callInfo)
	mock.lockStartTaskSequence.Unlock()
	return mock.StartTaskSequenceFunc(event)
}

// StartTaskSequenceCalls gets all the calls that were made to StartTaskSequence.
// Check the length with:
//     len(mockedIShipyardController.StartTaskSequenceCalls())
func (mock *IShipyardControllerMock) StartTaskSequenceCalls() []struct {
	Event models.Event
} {
	var calls []struct {
		Event models.Event
	}
	mock.lockStartTaskSequence.RLock()
	calls = mock.calls.StartTaskSequence
	mock.lockStartTaskSequence.RUnlock()
	return calls
}
