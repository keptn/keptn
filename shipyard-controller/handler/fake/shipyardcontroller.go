// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fake

import (
	"github.com/keptn/keptn/shipyard-controller/common"
	"github.com/keptn/keptn/shipyard-controller/handler"
	"github.com/keptn/keptn/shipyard-controller/models"
	"sync"
)

// IShipyardControllerMock is a mock implementation of handler.IShipyardController.
//
// 	func TestSomethingThatUsesIShipyardController(t *testing.T) {
//
// 		// make and configure a mocked handler.IShipyardController
// 		mockedIShipyardController := &IShipyardControllerMock{
// 			CancelSequenceFunc: func(cancelRequest handler.SequenceCancellation) error {
// 				panic("mock out the CancelSequence method")
// 			},
// 			GetAllTriggeredEventsFunc: func(filter common.EventFilter) ([]models.Event, error) {
// 				panic("mock out the GetAllTriggeredEvents method")
// 			},
// 			GetTriggeredEventsOfProjectFunc: func(project string, filter common.EventFilter) ([]models.Event, error) {
// 				panic("mock out the GetTriggeredEventsOfProject method")
// 			},
// 			HandleIncomingEventFunc: func(event models.Event, waitForCompletion bool) error {
// 				panic("mock out the HandleIncomingEvent method")
// 			},
// 		}
//
// 		// use mockedIShipyardController in code that requires handler.IShipyardController
// 		// and then make assertions.
//
// 	}
type IShipyardControllerMock struct {
	// CancelSequenceFunc mocks the CancelSequence method.
	CancelSequenceFunc func(cancelRequest handler.SequenceCancellation) error

	// GetAllTriggeredEventsFunc mocks the GetAllTriggeredEvents method.
	GetAllTriggeredEventsFunc func(filter common.EventFilter) ([]models.Event, error)

	// GetTriggeredEventsOfProjectFunc mocks the GetTriggeredEventsOfProject method.
	GetTriggeredEventsOfProjectFunc func(project string, filter common.EventFilter) ([]models.Event, error)

	// HandleIncomingEventFunc mocks the HandleIncomingEvent method.
	HandleIncomingEventFunc func(event models.Event, waitForCompletion bool) error

	// calls tracks calls to the methods.
	calls struct {
		// CancelSequence holds details about calls to the CancelSequence method.
		CancelSequence []struct {
			// CancelRequest is the cancelRequest argument value.
			CancelRequest handler.SequenceCancellation
		}
		// GetAllTriggeredEvents holds details about calls to the GetAllTriggeredEvents method.
		GetAllTriggeredEvents []struct {
			// Filter is the filter argument value.
			Filter common.EventFilter
		}
		// GetTriggeredEventsOfProject holds details about calls to the GetTriggeredEventsOfProject method.
		GetTriggeredEventsOfProject []struct {
			// Project is the project argument value.
			Project string
			// Filter is the filter argument value.
			Filter common.EventFilter
		}
		// HandleIncomingEvent holds details about calls to the HandleIncomingEvent method.
		HandleIncomingEvent []struct {
			// Event is the event argument value.
			Event models.Event
			// WaitForCompletion is the waitForCompletion argument value.
			WaitForCompletion bool
		}
	}
	lockCancelSequence              sync.RWMutex
	lockGetAllTriggeredEvents       sync.RWMutex
	lockGetTriggeredEventsOfProject sync.RWMutex
	lockHandleIncomingEvent         sync.RWMutex
}

// CancelSequence calls CancelSequenceFunc.
func (mock *IShipyardControllerMock) CancelSequence(cancelRequest handler.SequenceCancellation) error {
	if mock.CancelSequenceFunc == nil {
		panic("IShipyardControllerMock.CancelSequenceFunc: method is nil but IShipyardController.CancelSequence was just called")
	}
	callInfo := struct {
		CancelRequest handler.SequenceCancellation
	}{
		CancelRequest: cancelRequest,
	}
	mock.lockCancelSequence.Lock()
	mock.calls.CancelSequence = append(mock.calls.CancelSequence, callInfo)
	mock.lockCancelSequence.Unlock()
	return mock.CancelSequenceFunc(cancelRequest)
}

// CancelSequenceCalls gets all the calls that were made to CancelSequence.
// Check the length with:
//     len(mockedIShipyardController.CancelSequenceCalls())
func (mock *IShipyardControllerMock) CancelSequenceCalls() []struct {
	CancelRequest handler.SequenceCancellation
} {
	var calls []struct {
		CancelRequest handler.SequenceCancellation
	}
	mock.lockCancelSequence.RLock()
	calls = mock.calls.CancelSequence
	mock.lockCancelSequence.RUnlock()
	return calls
}

// GetAllTriggeredEvents calls GetAllTriggeredEventsFunc.
func (mock *IShipyardControllerMock) GetAllTriggeredEvents(filter common.EventFilter) ([]models.Event, error) {
	if mock.GetAllTriggeredEventsFunc == nil {
		panic("IShipyardControllerMock.GetAllTriggeredEventsFunc: method is nil but IShipyardController.GetAllTriggeredEvents was just called")
	}
	callInfo := struct {
		Filter common.EventFilter
	}{
		Filter: filter,
	}
	mock.lockGetAllTriggeredEvents.Lock()
	mock.calls.GetAllTriggeredEvents = append(mock.calls.GetAllTriggeredEvents, callInfo)
	mock.lockGetAllTriggeredEvents.Unlock()
	return mock.GetAllTriggeredEventsFunc(filter)
}

// GetAllTriggeredEventsCalls gets all the calls that were made to GetAllTriggeredEvents.
// Check the length with:
//     len(mockedIShipyardController.GetAllTriggeredEventsCalls())
func (mock *IShipyardControllerMock) GetAllTriggeredEventsCalls() []struct {
	Filter common.EventFilter
} {
	var calls []struct {
		Filter common.EventFilter
	}
	mock.lockGetAllTriggeredEvents.RLock()
	calls = mock.calls.GetAllTriggeredEvents
	mock.lockGetAllTriggeredEvents.RUnlock()
	return calls
}

// GetTriggeredEventsOfProject calls GetTriggeredEventsOfProjectFunc.
func (mock *IShipyardControllerMock) GetTriggeredEventsOfProject(project string, filter common.EventFilter) ([]models.Event, error) {
	if mock.GetTriggeredEventsOfProjectFunc == nil {
		panic("IShipyardControllerMock.GetTriggeredEventsOfProjectFunc: method is nil but IShipyardController.GetTriggeredEventsOfProject was just called")
	}
	callInfo := struct {
		Project string
		Filter  common.EventFilter
	}{
		Project: project,
		Filter:  filter,
	}
	mock.lockGetTriggeredEventsOfProject.Lock()
	mock.calls.GetTriggeredEventsOfProject = append(mock.calls.GetTriggeredEventsOfProject, callInfo)
	mock.lockGetTriggeredEventsOfProject.Unlock()
	return mock.GetTriggeredEventsOfProjectFunc(project, filter)
}

// GetTriggeredEventsOfProjectCalls gets all the calls that were made to GetTriggeredEventsOfProject.
// Check the length with:
//     len(mockedIShipyardController.GetTriggeredEventsOfProjectCalls())
func (mock *IShipyardControllerMock) GetTriggeredEventsOfProjectCalls() []struct {
	Project string
	Filter  common.EventFilter
} {
	var calls []struct {
		Project string
		Filter  common.EventFilter
	}
	mock.lockGetTriggeredEventsOfProject.RLock()
	calls = mock.calls.GetTriggeredEventsOfProject
	mock.lockGetTriggeredEventsOfProject.RUnlock()
	return calls
}

// HandleIncomingEvent calls HandleIncomingEventFunc.
func (mock *IShipyardControllerMock) HandleIncomingEvent(event models.Event, waitForCompletion bool) error {
	if mock.HandleIncomingEventFunc == nil {
		panic("IShipyardControllerMock.HandleIncomingEventFunc: method is nil but IShipyardController.HandleIncomingEvent was just called")
	}
	callInfo := struct {
		Event             models.Event
		WaitForCompletion bool
	}{
		Event:             event,
		WaitForCompletion: waitForCompletion,
	}
	mock.lockHandleIncomingEvent.Lock()
	mock.calls.HandleIncomingEvent = append(mock.calls.HandleIncomingEvent, callInfo)
	mock.lockHandleIncomingEvent.Unlock()
	return mock.HandleIncomingEventFunc(event, waitForCompletion)
}

// HandleIncomingEventCalls gets all the calls that were made to HandleIncomingEvent.
// Check the length with:
//     len(mockedIShipyardController.HandleIncomingEventCalls())
func (mock *IShipyardControllerMock) HandleIncomingEventCalls() []struct {
	Event             models.Event
	WaitForCompletion bool
} {
	var calls []struct {
		Event             models.Event
		WaitForCompletion bool
	}
	mock.lockHandleIncomingEvent.RLock()
	calls = mock.calls.HandleIncomingEvent
	mock.lockHandleIncomingEvent.RUnlock()
	return calls
}
