// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fake

import (
	scmodels "github.com/keptn/keptn/shipyard-controller/models"
	"sync"
)

// ILogManagerMock is a mock implementation of handler.ILogManager.
//
// 	func TestSomethingThatUsesILogManager(t *testing.T) {
//
// 		// make and configure a mocked handler.ILogManager
// 		mockedILogManager := &ILogManagerMock{
// 			CreateLogEntriesFunc: func(entry scmodels.CreateLogsRequest) error {
// 				panic("mock out the CreateLogEntries method")
// 			},
// 			DeleteLogEntriesFunc: func(params scmodels.DeleteLogParams) error {
// 				panic("mock out the DeleteLogEntries method")
// 			},
// 			GetLogEntriesFunc: func(filter scmodels.GetLogParams) (*scmodels.GetLogsResponse, error) {
// 				panic("mock out the GetLogEntries method")
// 			},
// 		}
//
// 		// use mockedILogManager in code that requires handler.ILogManager
// 		// and then make assertions.
//
// 	}
type ILogManagerMock struct {
	// CreateLogEntriesFunc mocks the CreateLogEntries method.
	CreateLogEntriesFunc func(entry scmodels.CreateLogsRequest) error

	// DeleteLogEntriesFunc mocks the DeleteLogEntries method.
	DeleteLogEntriesFunc func(params scmodels.DeleteLogParams) error

	// GetLogEntriesFunc mocks the GetLogEntries method.
	GetLogEntriesFunc func(filter scmodels.GetLogParams) (*scmodels.GetLogsResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateLogEntries holds details about calls to the CreateLogEntries method.
		CreateLogEntries []struct {
			// Entry is the entry argument value.
			Entry scmodels.CreateLogsRequest
		}
		// DeleteLogEntries holds details about calls to the DeleteLogEntries method.
		DeleteLogEntries []struct {
			// Params is the params argument value.
			Params scmodels.DeleteLogParams
		}
		// GetLogEntries holds details about calls to the GetLogEntries method.
		GetLogEntries []struct {
			// Filter is the filter argument value.
			Filter scmodels.GetLogParams
		}
	}
	lockCreateLogEntries sync.RWMutex
	lockDeleteLogEntries sync.RWMutex
	lockGetLogEntries    sync.RWMutex
}

// CreateLogEntries calls CreateLogEntriesFunc.
func (mock *ILogManagerMock) CreateLogEntries(entry scmodels.CreateLogsRequest) error {
	if mock.CreateLogEntriesFunc == nil {
		panic("ILogManagerMock.CreateLogEntriesFunc: method is nil but ILogManager.CreateLogEntries was just called")
	}
	callInfo := struct {
		Entry scmodels.CreateLogsRequest
	}{
		Entry: entry,
	}
	mock.lockCreateLogEntries.Lock()
	mock.calls.CreateLogEntries = append(mock.calls.CreateLogEntries, callInfo)
	mock.lockCreateLogEntries.Unlock()
	return mock.CreateLogEntriesFunc(entry)
}

// CreateLogEntriesCalls gets all the calls that were made to CreateLogEntries.
// Check the length with:
//     len(mockedILogManager.CreateLogEntriesCalls())
func (mock *ILogManagerMock) CreateLogEntriesCalls() []struct {
	Entry scmodels.CreateLogsRequest
} {
	var calls []struct {
		Entry scmodels.CreateLogsRequest
	}
	mock.lockCreateLogEntries.RLock()
	calls = mock.calls.CreateLogEntries
	mock.lockCreateLogEntries.RUnlock()
	return calls
}

// DeleteLogEntries calls DeleteLogEntriesFunc.
func (mock *ILogManagerMock) DeleteLogEntries(params scmodels.DeleteLogParams) error {
	if mock.DeleteLogEntriesFunc == nil {
		panic("ILogManagerMock.DeleteLogEntriesFunc: method is nil but ILogManager.DeleteLogEntries was just called")
	}
	callInfo := struct {
		Params scmodels.DeleteLogParams
	}{
		Params: params,
	}
	mock.lockDeleteLogEntries.Lock()
	mock.calls.DeleteLogEntries = append(mock.calls.DeleteLogEntries, callInfo)
	mock.lockDeleteLogEntries.Unlock()
	return mock.DeleteLogEntriesFunc(params)
}

// DeleteLogEntriesCalls gets all the calls that were made to DeleteLogEntries.
// Check the length with:
//     len(mockedILogManager.DeleteLogEntriesCalls())
func (mock *ILogManagerMock) DeleteLogEntriesCalls() []struct {
	Params scmodels.DeleteLogParams
} {
	var calls []struct {
		Params scmodels.DeleteLogParams
	}
	mock.lockDeleteLogEntries.RLock()
	calls = mock.calls.DeleteLogEntries
	mock.lockDeleteLogEntries.RUnlock()
	return calls
}

// GetLogEntries calls GetLogEntriesFunc.
func (mock *ILogManagerMock) GetLogEntries(filter scmodels.GetLogParams) (*scmodels.GetLogsResponse, error) {
	if mock.GetLogEntriesFunc == nil {
		panic("ILogManagerMock.GetLogEntriesFunc: method is nil but ILogManager.GetLogEntries was just called")
	}
	callInfo := struct {
		Filter scmodels.GetLogParams
	}{
		Filter: filter,
	}
	mock.lockGetLogEntries.Lock()
	mock.calls.GetLogEntries = append(mock.calls.GetLogEntries, callInfo)
	mock.lockGetLogEntries.Unlock()
	return mock.GetLogEntriesFunc(filter)
}

// GetLogEntriesCalls gets all the calls that were made to GetLogEntries.
// Check the length with:
//     len(mockedILogManager.GetLogEntriesCalls())
func (mock *ILogManagerMock) GetLogEntriesCalls() []struct {
	Filter scmodels.GetLogParams
} {
	var calls []struct {
		Filter scmodels.GetLogParams
	}
	mock.lockGetLogEntries.RLock()
	calls = mock.calls.GetLogEntries
	mock.lockGetLogEntries.RUnlock()
	return calls
}
