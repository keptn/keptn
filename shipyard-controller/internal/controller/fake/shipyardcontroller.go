// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fake

import (
	"context"
	apimodels "github.com/keptn/go-utils/pkg/api/models"
	"github.com/keptn/keptn/shipyard-controller/internal/common"
	"sync"
)

// IShipyardControllerMock is a mock implementation of controller.IShipyardController.
//
// 	func TestSomethingThatUsesIShipyardController(t *testing.T) {
//
// 		// make and configure a mocked controller.IShipyardController
// 		mockedIShipyardController := &IShipyardControllerMock{
// 			ControlSequenceFunc: func(controlSequence apimodels.SequenceControl) error {
// 				panic("mock out the ControlSequence method")
// 			},
// 			GetAllTriggeredEventsFunc: func(filter common.EventFilter) ([]apimodels.KeptnContextExtendedCE, error) {
// 				panic("mock out the GetAllTriggeredEvents method")
// 			},
// 			GetTriggeredEventsOfProjectFunc: func(project string, filter common.EventFilter) ([]apimodels.KeptnContextExtendedCE, error) {
// 				panic("mock out the GetTriggeredEventsOfProject method")
// 			},
// 			HandleIncomingEventFunc: func(event apimodels.KeptnContextExtendedCE, waitForCompletion bool) error {
// 				panic("mock out the HandleIncomingEvent method")
// 			},
// 			StartDispatchersFunc: func(ctx context.Context, mode common.SDMode)  {
// 				panic("mock out the StartDispatchers method")
// 			},
// 			StartTaskSequenceFunc: func(event apimodels.KeptnContextExtendedCE) error {
// 				panic("mock out the StartTaskSequence method")
// 			},
// 			StopDispatchersFunc: func()  {
// 				panic("mock out the StopDispatchers method")
// 			},
// 		}
//
// 		// use mockedIShipyardController in code that requires controller.IShipyardController
// 		// and then make assertions.
//
// 	}
type IShipyardControllerMock struct {
	// ControlSequenceFunc mocks the ControlSequence method.
	ControlSequenceFunc func(controlSequence apimodels.SequenceControl) error

	// GetAllTriggeredEventsFunc mocks the GetAllTriggeredEvents method.
	GetAllTriggeredEventsFunc func(filter common.EventFilter) ([]apimodels.KeptnContextExtendedCE, error)

	// GetTriggeredEventsOfProjectFunc mocks the GetTriggeredEventsOfProject method.
	GetTriggeredEventsOfProjectFunc func(project string, filter common.EventFilter) ([]apimodels.KeptnContextExtendedCE, error)

	// HandleIncomingEventFunc mocks the HandleIncomingEvent method.
	HandleIncomingEventFunc func(event apimodels.KeptnContextExtendedCE, waitForCompletion bool) error

	// StartDispatchersFunc mocks the StartDispatchers method.
	StartDispatchersFunc func(ctx context.Context, mode common.SDMode)

	// StartTaskSequenceFunc mocks the StartTaskSequence method.
	StartTaskSequenceFunc func(event apimodels.KeptnContextExtendedCE) error

	// StopDispatchersFunc mocks the StopDispatchers method.
	StopDispatchersFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// ControlSequence holds details about calls to the ControlSequence method.
		ControlSequence []struct {
			// ControlSequence is the controlSequence argument value.
			ControlSequence apimodels.SequenceControl
		}
		// GetAllTriggeredEvents holds details about calls to the GetAllTriggeredEvents method.
		GetAllTriggeredEvents []struct {
			// Filter is the filter argument value.
			Filter common.EventFilter
		}
		// GetTriggeredEventsOfProject holds details about calls to the GetTriggeredEventsOfProject method.
		GetTriggeredEventsOfProject []struct {
			// Project is the project argument value.
			Project string
			// Filter is the filter argument value.
			Filter common.EventFilter
		}
		// HandleIncomingEvent holds details about calls to the HandleIncomingEvent method.
		HandleIncomingEvent []struct {
			// Event is the event argument value.
			Event apimodels.KeptnContextExtendedCE
			// WaitForCompletion is the waitForCompletion argument value.
			WaitForCompletion bool
		}
		// StartDispatchers holds details about calls to the StartDispatchers method.
		StartDispatchers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Mode is the mode argument value.
			Mode common.SDMode
		}
		// StartTaskSequence holds details about calls to the StartTaskSequence method.
		StartTaskSequence []struct {
			// Event is the event argument value.
			Event apimodels.KeptnContextExtendedCE
		}
		// StopDispatchers holds details about calls to the StopDispatchers method.
		StopDispatchers []struct {
		}
	}
	lockControlSequence             sync.RWMutex
	lockGetAllTriggeredEvents       sync.RWMutex
	lockGetTriggeredEventsOfProject sync.RWMutex
	lockHandleIncomingEvent         sync.RWMutex
	lockStartDispatchers            sync.RWMutex
	lockStartTaskSequence           sync.RWMutex
	lockStopDispatchers             sync.RWMutex
}

// ControlSequence calls ControlSequenceFunc.
func (mock *IShipyardControllerMock) ControlSequence(controlSequence apimodels.SequenceControl) error {
	if mock.ControlSequenceFunc == nil {
		panic("IShipyardControllerMock.ControlSequenceFunc: method is nil but IShipyardController.ControlSequence was just called")
	}
	callInfo := struct {
		ControlSequence apimodels.SequenceControl
	}{
		ControlSequence: controlSequence,
	}
	mock.lockControlSequence.Lock()
	mock.calls.ControlSequence = append(mock.calls.ControlSequence, callInfo)
	mock.lockControlSequence.Unlock()
	return mock.ControlSequenceFunc(controlSequence)
}

// ControlSequenceCalls gets all the calls that were made to ControlSequence.
// Check the length with:
//     len(mockedIShipyardController.ControlSequenceCalls())
func (mock *IShipyardControllerMock) ControlSequenceCalls() []struct {
	ControlSequence apimodels.SequenceControl
} {
	var calls []struct {
		ControlSequence apimodels.SequenceControl
	}
	mock.lockControlSequence.RLock()
	calls = mock.calls.ControlSequence
	mock.lockControlSequence.RUnlock()
	return calls
}

// GetAllTriggeredEvents calls GetAllTriggeredEventsFunc.
func (mock *IShipyardControllerMock) GetAllTriggeredEvents(filter common.EventFilter) ([]apimodels.KeptnContextExtendedCE, error) {
	if mock.GetAllTriggeredEventsFunc == nil {
		panic("IShipyardControllerMock.GetAllTriggeredEventsFunc: method is nil but IShipyardController.GetAllTriggeredEvents was just called")
	}
	callInfo := struct {
		Filter common.EventFilter
	}{
		Filter: filter,
	}
	mock.lockGetAllTriggeredEvents.Lock()
	mock.calls.GetAllTriggeredEvents = append(mock.calls.GetAllTriggeredEvents, callInfo)
	mock.lockGetAllTriggeredEvents.Unlock()
	return mock.GetAllTriggeredEventsFunc(filter)
}

// GetAllTriggeredEventsCalls gets all the calls that were made to GetAllTriggeredEvents.
// Check the length with:
//     len(mockedIShipyardController.GetAllTriggeredEventsCalls())
func (mock *IShipyardControllerMock) GetAllTriggeredEventsCalls() []struct {
	Filter common.EventFilter
} {
	var calls []struct {
		Filter common.EventFilter
	}
	mock.lockGetAllTriggeredEvents.RLock()
	calls = mock.calls.GetAllTriggeredEvents
	mock.lockGetAllTriggeredEvents.RUnlock()
	return calls
}

// GetTriggeredEventsOfProject calls GetTriggeredEventsOfProjectFunc.
func (mock *IShipyardControllerMock) GetTriggeredEventsOfProject(project string, filter common.EventFilter) ([]apimodels.KeptnContextExtendedCE, error) {
	if mock.GetTriggeredEventsOfProjectFunc == nil {
		panic("IShipyardControllerMock.GetTriggeredEventsOfProjectFunc: method is nil but IShipyardController.GetTriggeredEventsOfProject was just called")
	}
	callInfo := struct {
		Project string
		Filter  common.EventFilter
	}{
		Project: project,
		Filter:  filter,
	}
	mock.lockGetTriggeredEventsOfProject.Lock()
	mock.calls.GetTriggeredEventsOfProject = append(mock.calls.GetTriggeredEventsOfProject, callInfo)
	mock.lockGetTriggeredEventsOfProject.Unlock()
	return mock.GetTriggeredEventsOfProjectFunc(project, filter)
}

// GetTriggeredEventsOfProjectCalls gets all the calls that were made to GetTriggeredEventsOfProject.
// Check the length with:
//     len(mockedIShipyardController.GetTriggeredEventsOfProjectCalls())
func (mock *IShipyardControllerMock) GetTriggeredEventsOfProjectCalls() []struct {
	Project string
	Filter  common.EventFilter
} {
	var calls []struct {
		Project string
		Filter  common.EventFilter
	}
	mock.lockGetTriggeredEventsOfProject.RLock()
	calls = mock.calls.GetTriggeredEventsOfProject
	mock.lockGetTriggeredEventsOfProject.RUnlock()
	return calls
}

// HandleIncomingEvent calls HandleIncomingEventFunc.
func (mock *IShipyardControllerMock) HandleIncomingEvent(event apimodels.KeptnContextExtendedCE, waitForCompletion bool) error {
	if mock.HandleIncomingEventFunc == nil {
		panic("IShipyardControllerMock.HandleIncomingEventFunc: method is nil but IShipyardController.HandleIncomingEvent was just called")
	}
	callInfo := struct {
		Event             apimodels.KeptnContextExtendedCE
		WaitForCompletion bool
	}{
		Event:             event,
		WaitForCompletion: waitForCompletion,
	}
	mock.lockHandleIncomingEvent.Lock()
	mock.calls.HandleIncomingEvent = append(mock.calls.HandleIncomingEvent, callInfo)
	mock.lockHandleIncomingEvent.Unlock()
	return mock.HandleIncomingEventFunc(event, waitForCompletion)
}

// HandleIncomingEventCalls gets all the calls that were made to HandleIncomingEvent.
// Check the length with:
//     len(mockedIShipyardController.HandleIncomingEventCalls())
func (mock *IShipyardControllerMock) HandleIncomingEventCalls() []struct {
	Event             apimodels.KeptnContextExtendedCE
	WaitForCompletion bool
} {
	var calls []struct {
		Event             apimodels.KeptnContextExtendedCE
		WaitForCompletion bool
	}
	mock.lockHandleIncomingEvent.RLock()
	calls = mock.calls.HandleIncomingEvent
	mock.lockHandleIncomingEvent.RUnlock()
	return calls
}

// StartDispatchers calls StartDispatchersFunc.
func (mock *IShipyardControllerMock) StartDispatchers(ctx context.Context, mode common.SDMode) {
	if mock.StartDispatchersFunc == nil {
		panic("IShipyardControllerMock.StartDispatchersFunc: method is nil but IShipyardController.StartDispatchers was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Mode common.SDMode
	}{
		Ctx:  ctx,
		Mode: mode,
	}
	mock.lockStartDispatchers.Lock()
	mock.calls.StartDispatchers = append(mock.calls.StartDispatchers, callInfo)
	mock.lockStartDispatchers.Unlock()
	mock.StartDispatchersFunc(ctx, mode)
}

// StartDispatchersCalls gets all the calls that were made to StartDispatchers.
// Check the length with:
//     len(mockedIShipyardController.StartDispatchersCalls())
func (mock *IShipyardControllerMock) StartDispatchersCalls() []struct {
	Ctx  context.Context
	Mode common.SDMode
} {
	var calls []struct {
		Ctx  context.Context
		Mode common.SDMode
	}
	mock.lockStartDispatchers.RLock()
	calls = mock.calls.StartDispatchers
	mock.lockStartDispatchers.RUnlock()
	return calls
}

// StartTaskSequence calls StartTaskSequenceFunc.
func (mock *IShipyardControllerMock) StartTaskSequence(event apimodels.KeptnContextExtendedCE) error {
	if mock.StartTaskSequenceFunc == nil {
		panic("IShipyardControllerMock.StartTaskSequenceFunc: method is nil but IShipyardController.StartTaskSequence was just called")
	}
	callInfo := struct {
		Event apimodels.KeptnContextExtendedCE
	}{
		Event: event,
	}
	mock.lockStartTaskSequence.Lock()
	mock.calls.StartTaskSequence = append(mock.calls.StartTaskSequence, callInfo)
	mock.lockStartTaskSequence.Unlock()
	return mock.StartTaskSequenceFunc(event)
}

// StartTaskSequenceCalls gets all the calls that were made to StartTaskSequence.
// Check the length with:
//     len(mockedIShipyardController.StartTaskSequenceCalls())
func (mock *IShipyardControllerMock) StartTaskSequenceCalls() []struct {
	Event apimodels.KeptnContextExtendedCE
} {
	var calls []struct {
		Event apimodels.KeptnContextExtendedCE
	}
	mock.lockStartTaskSequence.RLock()
	calls = mock.calls.StartTaskSequence
	mock.lockStartTaskSequence.RUnlock()
	return calls
}

// StopDispatchers calls StopDispatchersFunc.
func (mock *IShipyardControllerMock) StopDispatchers() {
	if mock.StopDispatchersFunc == nil {
		panic("IShipyardControllerMock.StopDispatchersFunc: method is nil but IShipyardController.StopDispatchers was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStopDispatchers.Lock()
	mock.calls.StopDispatchers = append(mock.calls.StopDispatchers, callInfo)
	mock.lockStopDispatchers.Unlock()
	mock.StopDispatchersFunc()
}

// StopDispatchersCalls gets all the calls that were made to StopDispatchers.
// Check the length with:
//     len(mockedIShipyardController.StopDispatchersCalls())
func (mock *IShipyardControllerMock) StopDispatchersCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStopDispatchers.RLock()
	calls = mock.calls.StopDispatchers
	mock.lockStopDispatchers.RUnlock()
	return calls
}
